## 响应式原理
- 我们在使用Vue的时候，赋值属性获得属性都是直接使用的vue实例
- 我们在设计属性值的时候，页面的数据更新

- 实际开发中对象一般是有多级的
> 怎么处理呢，使用递归

- 对于对象可以使用 递归 实现响应化，但是数组我们也是需要处理诸如 push pop 等方法
- 要做什么事情呢
- 1. 在改变数组的时候，要发出通知
  > vue 2中的缺陷，数组发生变化，设置length 无法通知，(vue3中使用 proxy 语法解决了这个问题)
- 2. 加入的元素也应该变为响应式的
## 技巧: 如果一个 函数已经定义了，但是我们需要扩展其功能，一般的处理方法为
> 继承关系： arr -> Array.prototype -> Object.prototype -> ...
> 继承关系： arr -> 在这里改写方法 -> Array.prototype -> Object.prototype -> ...
    1. 使用一个临时的函数名储存函数
    2. 重新定义原来的函数
    3. 定义扩展的功能
    4. 调用临时的那个函数

## 扩展数组中 push、pop、splice等怎么处理
- 直接修改 Array.prototype 不行，会污染全部的数组
- 修改要进行响应化的数组的原型(__proto__), **可以**

### 遗留问题： 已经将对象改为响应式的了，但是如果直接给对象赋值，赋值另一个对象，那么就不是响应的了，怎么处理呢？
 在set中添加 reactify(newValue) 即可 

### 代理防范：(app.name app._data.name)
也就是将 app._data 中的成员映射到 app 上

由于需要在更新数据的时候，更新页面的内容
所以 在 app._data 访问的成员由于 _app 访问的成员应该是同一个成员

引入一个函数 proxy(target, src, prop) 将 target 中的操作映射到 src.prop 上
这里是因为当时没有 proxy 语法（ES6）

我们之前处理的 reactify 方法已经不行了，我们需要一个新的方法进行处理
提供一个 Observer 方法，在方法中对属性进行处理
可以将这个方法封装到 intData 方法中

### 解释 proxy
> 在vue中，不希望访问 _开头的私有数据
> 在vue中，潜规则：_开头的数据是私有数据， $开头的数据是只读数据
 重点： 在访问 app.xxx 属性时候就是访问 app._data.xxx 属性
 ```js
 Object.defineProperty(app, key, {
   get(){
     return app._data[key]
   },
   set(newValue){
     app._data[key] = newValue
     return true
   }
 })
 ```
 问题： 
 在 vue 中 不仅仅是只有data 属性，诸如 props，methods，computed 等属性都会挂载在 vue 实例上
 优化如下
 ```js
 function proxy(app, prop, key){
   Object.defineProperty(app, key, {
     get(){
       return app.[prop][key]
     },
     set(newValue){
       app.[prop][key] = newValue
       return true
     }
   })
 }
 ```
// 将 _data 挂载在实例上
proxy(实例, '_data', 属性名)
// 将 _properties 挂载在实例上
proxy(实例, '_properties', 属性名)
...等

### 发布订阅模式
目的： 解耦，让各个模块之间没有紧密的联系
现在的处理方法是，属性在更新的时候调用 mountComponent 方法
问题：mountComponent 更新的是什么，？？？现在是全部的页面，待做优化处理 -> 当前虚拟 dom 对应的页面 DOM
  在vue中 整个的更新过程是按照 组件 为单位进行 **判断** 以节点为单位进行更新
  - 如果代码中没有自定义组件，那么在比较算法的时候，我们会将全部的模板 对应的虚拟 DOM 进行比较
  - 如果含有自定义组件，那么在比较算法时候，就会判断更新的是哪一部分的组件中的属性，只会判断更新数据的组件，其他组件不会更新
  复杂的页面是由很多组件构成，每一个属性要更新的时候都要调用 更新的方法

  **目标：：：如果修改了什么属性，就尽可能地只更新这些属性对应的页面 DOM**
  这样的话，就一定不能将更新时候的代码写死了

  例子：预售-》可能一个东西没有现货，告诉老板，如果东西到了就告诉我。。
  老板就是发布者，
  订阅什么东西作为中间媒介
  我就是订阅者。。。

  使用代码的结构来描述：
  1. 老板提供一个账簿(数组)
  2. 我可以根据需求订阅我的商品(老板要记录下 谁 订阅了什么东西, 也就是需要在 数组 中存储某些东西)
  3. 等待，可以做其他的事情
  4. 货品来到以后，老板就查看账簿(数组)，然后挨个打电话通知(遍历数组，取出数组中的元素来使用其中的方法)
  5. 实际上就是事件模型

  1. 有一个event 对象
  2. on off emit 等方法
  
  实现事件模型，思考怎么用？
  1. event 是一个全局对象
  2. event.on('事件名', 处理函数) 订阅事件
    1. 事件可以连续订阅
    2. 事件可以移除：event.off()
      1. 移除所有的事件
      2. 移除某一个类型的事件
      3. 移除某一个类型的某一个处理函数
  3. 写别的代码
  4. event.emit("事件名", 参数) 先前注册的事件处理函数就会依次调用

  原因：
    1. 用来描述发布订阅模式
    2. 后面会使用到事件

发布订阅模式：
1. 中间的**全局的容器**，用来**存储**可以被触发的东西(函数，对象)
2. 需要一个方法，可以往容器里**传入**东西(函数，对象)
3. 需要一个方法，可以将容器中的东西取出来**使用**(函数调用，对象的方法调用)

Vue 模型
页面中的变更(diff) 是以组件为单位，
- 如果页面中只有一个组件(vue实例) 不会有性能损失
- 如果页面中有多个组件(多个watcher的一种情况)，那么第一次会有多个组件的watcher 存入到全局 watcher 中
  - 如果修改了局部的数据（例如其中一个组件的数据）
  - 表示只会对该组件进行 diff  算法，也就是说只会重新生成 该组件的抽象语法树
  - 只会访问该组件的 watcher
  - 也就表示再次往全局存储的只有该组件的 watcher
  - 页面更新时候也就只需要更新一部分

## 改写 observer 函数
  目前的缺陷： 
    - 无法处理数组
    - 响应式无法在中间集成 watcher 处理
    - 我们实现的 reactify 需要和实例紧紧的绑在一起,需要进行分离(解耦

## 引入 watcher 
问题：
  - 模型
  - 关于 this 的问题


实现
分为两步
  1. 只考虑修改后刷新(响应式)
  2. 在考虑依赖收集(优化)

在 Vue 中提供一个构造函数 Watcher
Watcher 会有一些方法
  - get() 用来计算或者执行函数
  - update() 公共的外部方法，该方法会触发内部的 run 方法
  - run() 运行，用来判断内部是使用异步运行还是同步运行等，这个方法最终会调用内部的 get 方法
  - cleanUpDep() 简单理解为清除队列

我们的页面渲染时上面哪一个方法执行的： get() 方法
我们的 watchers 实例有一个属性vm， 表示的是当前的 vue 实例

## 引入 Dep 对象
该对象提供 依赖收集(depend) 的功能，和派发更新(notify)的功能
在 notify 中去调用 watcher 中的 update 方法 

## Watcher 与 Dep
之前将渲染 Watcher 放在全局作用域上，这样处理时有问题的
- vue 项目中包含很多组件，各个组件是**自治的**
- 那么 watcher 就可能有多个
- 每一个watcher 用于描述一个渲染行为 或者 计算行为
  - 子组件发生数据的更新，页面需要重新渲染(真正的vue中是**局部**渲染)
  - 例如 vue中的推荐是使用 计算属性 代替复杂的 插值表达式
  - 计算属性是会伴随其使用的属性的变化而变化的
  - 对于计算属性，只要其依赖的属性发生变化，那么就会促使计算属性**重新计算**(由对应的Watcher完成)

- 依赖收集和派发更新是怎么运行起来的
 - 所谓的依赖收集 实际上就是告诉当前的 watcher 什么属性被访问了
 - 那么在这个 watcher 计算的时候或者 渲染页面的时候将会根据这个 收集进行更新

- 如何 将 属性与当前 watcher 关联起来
 - 在全局准备一个 targetStack (watcher 栈，简单的理解为 watcher "数组," 把一个操作中需要操作的 watcher 存储起来)
 - 在watcher 调用 get 方法时候，将当前watcher 放到全局，在get结束之后，将这个全局 watcher 进行移除
 - 提供 pushTarget popTarget
 在每一个属性中都有一个 Dep 属性

我们在访问对象属性的时候(get) ，我们的渲染函数 watcher 就在全局中
将 属性与 watcher 关联，其实就是将当前渲染的 watcher 存储到 属性相关的 dep 中
同时， 将 dep 也存储到 当前全局的 watcher 中（互相引用的关系）

- 属性引用了当前的渲染 watcher **属性知道谁渲染它**
- 当前渲染 watcher 引用了访问的属性 Dep ,**当前的watcher知道渲染了什么属性**

我们的dep 有一个方法 叫做 notify ,内部就是将 dep 中的 subs 取出来，依次调用 update 方法
subs 中存储的是 **知道要渲染什么属性的watcher**

 ## Observer 对象
